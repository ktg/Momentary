<!DOCTYPE html>
<html lang="en">
<head>
	<title>Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			background-color: #000000;
			overflow: hidden;
		}
	</style>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/lines/LineSegments2.js"></script>
<script src="js/lines/LineSegmentGeometry.js"></script>
<script src="js/lines/LineMaterial.js"></script>
<script src="js/lines/Lines2.js"></script>
<script src="js/lines/LineGeometry.js"></script>

<script>
	const segmentCount = 9;

	let primary = [];
	let secondary = [];

	for(let i = 0; i < segmentCount; i++) {
		const primaryItem = Math.floor(Math.random() * 3);
		let secondaryItem = primaryItem;
		while(secondaryItem === primaryItem) {
			secondaryItem = Math.floor(Math.random() * 3);
		}
        primary.push(primaryItem);
		secondary.push(secondaryItem);
	}

	const size = 50;
	const length = 50;

	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let selectedSegment = null;
	let segments = [];

	function generateTexture() {
		const size = 1024;
		const sideSize = 1024 / 3;
		const gradEnd = 256;
		const gradStart = 128;
		const gradSize = gradEnd - gradStart;
		const segmentSize = 1024 / primary.length;
		const canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		const context = canvas.getContext('2d');
		const image = context.getImageData(0, 0, size, size);
		let y = 0;
		let segment = 0;
		for (let i = 0, j = 0; i < image.data.length; i += 4, j++) {
			const x = j % size;
			const side = Math.floor(x / sideSize);
			const edge1 = side;
			const edge2 = (side + 1) % 3;
			if (x === 0) {
				y++;
				segment = Math.floor(y / segmentSize);
			}
			const primaryEdge = primary[segment];
			const secondaryEdge = secondary[segment];
			let value = 72;
			if(edge1 === primaryEdge && edge2 === secondaryEdge) {
				const progress = 1-((x % sideSize) / sideSize);
				value = (progress * gradSize) + gradStart;
			} else if(edge1 === secondaryEdge && edge2 === primaryEdge) {
				const progress = ((x % sideSize) / sideSize);
				value = (progress * gradSize) + gradStart;
			}

			image.data[i] = value;
			image.data[i + 1] = value;
			image.data[i + 2] = value;
			image.data[i + 3] = value;
		}
		context.putImageData(image, 0, 0);
		return canvas;
	}

	function colourFor(colour, offset) {
		if (offset === 1) {
			colour.setRGB(0, 1, 0);
		} else if (offset === 2) {
			colour.setRGB(0, 0, 1);
		} else {
			colour.setRGB(1, 0, 0);
		}
	}

	function createScene() {
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x000000);
		scene.fog = new THREE.FogExp2(0x000000, 0.001);

		const light = new THREE.AmbientLight(0xFFFFFF);
		scene.add(light);

		createObjects(scene);

		return scene;
	}

	function createToblerone() {
		const geometry = new THREE.CylinderBufferGeometry(size, size / 8, primary.length * length, 3, primary.length, true);
		const positions = geometry.attributes.position;
		const count = positions.count;
		geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
		const colour = new THREE.Color();
		const colours = geometry.attributes.color;

		for (let i = 0; i < count; i++) {
			colourFor(colour, i % 4);
			colours.setXYZ(i, colour.r, colour.g, colour.b);
		}

		return geometry;
	}

	function createSegments() {
		const geometry = new THREE.CylinderBufferGeometry(size, size, length, 3, 1, true);
		const tobleroneMaterial = new THREE.MeshPhongMaterial({
			color: 0xFFFFFF,
			flatShading: true,
			shininess: 0,
			side: THREE.DoubleSide,
			opacity: 0.5,
			transparent: true
		});

		for (let i = 0; i < primary.length; i++) {
			const segment = new THREE.Mesh(geometry, tobleroneMaterial);
			segment.position.z = (i * length) - ((primary.length - 1) * length * 0.5);

			segment.rotation.x = -Math.PI / 2;
			segment.rotation.y = -Math.PI;
			segment.rotation.z = -Math.PI;

			segments.push(segment);
		}
	}

	function createLine(positions) {
		let colour = new THREE.Color();
		let vertices = [];
		let lineColours = [];
		let previous = -1;
		for (let i = 0; i <= primary.length; i++) {
			const index = i * 4;
			const current = primary[i];
			if (vertices.length === 0) {
				const offset = index + current;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, current);
				lineColours.push(colour.r, colour.g, colour.b)

			} else {
				const offset = index + previous;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, previous);
				lineColours.push(colour.r, colour.g, colour.b)
			}
			if (previous !== current) {
				const offset = index + current;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, current);
				lineColours.push(colour.r, colour.g, colour.b)
			}

			previous = current;
		}

		const lineGeometry = new THREE.LineGeometry();
		lineGeometry.setPositions(vertices);
		lineGeometry.setColors(lineColours);

		const lineMaterial = new THREE.LineMaterial({
			color: 0xffffff,
			linewidth: 0.003,
			vertexColors: THREE.VertexColors,
			dashed: false
		});

		const line = new THREE.Line2(lineGeometry, lineMaterial);
		line.computeLineDistances();

		return line;
	}

	function createObjects(scene) {
		const tobleroneGeometry = createToblerone();
		const texture = new THREE.TextureLoader().load("textures/texture3.jpg");
		texture.anisotropy = 4;
		const alphaTexture = new THREE.Texture(generateTexture());
		alphaTexture.needsUpdate = true;
		alphaTexture.anisotropy = 4;
		const tobleroneMaterial = new THREE.MeshPhongMaterial({
			color: 0xFFFFFF,
			flatShading: true,
			vertexColors: THREE.VertexColors,
			shininess: 0,
			map: texture,
			alphaMap: alphaTexture,
			side: THREE.DoubleSide,
			opacity: 0.8,
			transparent: true
		});
		const toblerone = new THREE.Mesh(tobleroneGeometry, tobleroneMaterial);

		toblerone.add(createLine(tobleroneGeometry.attributes.position));

		createSegments();

		toblerone.rotation.x = -Math.PI / 2;
		toblerone.rotation.y = -Math.PI;
		toblerone.rotation.z = -Math.PI;
		scene.add(toblerone);
	}

	const renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

	const camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(0, -10, 500);

	const scene = createScene();

	window.addEventListener('resize', onWindowResize, false);
	document.addEventListener('mousemove', onDocumentMouseMove, false);

	animate();

	function animate() {
		requestAnimationFrame(animate);
		//controls.update();

		// raycaster.setFromCamera(mouse, camera);
		//
		// const intersects = raycaster.intersectObjects(segments);
		// if (intersects.length > 0) {
		// 	if (selectedSegment !== intersects[0].object) {
		// 		if (selectedSegment) {
		// 			scene.remove(selectedSegment);
		// 		}
		// 		selectedSegment = intersects[0].object;
		// 		scene.add(selectedSegment);
		// 	}
		// } else {
		// 	if (selectedSegment) {
		// 		scene.remove(selectedSegment);
		// 	}
		// 	selectedSegment = null;
		// }

		renderer.render(scene, camera);
	}

	function onDocumentMouseMove(event) {
		event.preventDefault();
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}
</script>
<div id=""></div>
</body>
</html>