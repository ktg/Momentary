<!DOCTYPE html>
<html lang="en">
<head>
	<title>Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			background-color: #000000;
			overflow: hidden;
		}
	</style>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/lines/LineSegments2.js"></script>
<script src="js/lines/LineSegmentGeometry.js"></script>
<script src="js/lines/LineMaterial.js"></script>
<script src="js/lines/Lines2.js"></script>
<script src="js/lines/LineGeometry.js"></script>

<script>
	function colourFor(colour, offset, strength = 1) {
		if (offset === 1) {
			colour.setRGB(0, 1, 0);
		} else if (offset === 2) {
			colour.setRGB(0, 0, 1);
		} else {
			colour.setRGB(1, 0, 0);
		}
	}

	function createToblerone() {
		const geometry = new THREE.CylinderBufferGeometry(50, 50, 50, 3, 1, true);
		const positions = geometry.attributes.position;
		const count = positions.count;
		geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
		const colour = new THREE.Color();
		const colours = geometry.attributes.color;

		for (let i = 0; i < count; i++) {
			colourFor(colour, i % 4);
			colours.setXYZ(i, colour.r, colour.g, colour.b);
		}

		return geometry;
	}

	function createScene() {
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x000000);
		scene.fog = new THREE.FogExp2(0x000000, 0.001);

		const light = new THREE.AmbientLight(0xFFFFFF);
		scene.add(light);

		createObjects(scene);

		return scene;
	}

	function createControls() {
		const controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
		controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
		controls.dampingFactor = 1;
		controls.screenSpacePanning = false;
		controls.minDistance = 100;
		controls.maxDistance = 500;
		controls.maxPolarAngle = Math.PI;

		return controls;
	}

	function createObjects(scene) {
		const material = new THREE.MeshPhongMaterial({
			color: 0xFFFFFF,
			flatShading: true,
			vertexColors: THREE.VertexColors,
			shininess: 0,
			side: THREE.DoubleSide,
			opacity: 0.5,
			transparent: true
		});
		const lineMaterial = new THREE.LineMaterial({
			color: 0xffffff,
			linewidth: 0.003,
			vertexColors: THREE.VertexColors,
			//resolution:  // to be set by renderer, eventually
			dashed: false
		});
		const wireframeMaterial = new THREE.MeshBasicMaterial({
			color: 0x000000,
			wireframe: true,
			opacity: 0.3,
			transparent: true
		});

		const geometry = createToblerone();
		let previous = -1;
		for (let i = 0; i <= trajectory.length; i++) {
			const mesh = new THREE.Mesh(geometry, material.clone());

			//const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
			//mesh.add(wireframe);
			//mesh.add(line);

			mesh.position.z = (i * 50) - (trajectory.length * 25);

			mesh.rotation.x = -Math.PI / 2;
			mesh.rotation.z = -Math.PI;
			scene.add(mesh);
		}

	}

	const trajectory = [0, 0, 0, 1, 0, 2, 0, 1, 2];

	const renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let selectedSegment;

	const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(400, 200, 0);

	const scene = createScene();
	const controls = createControls();

	window.addEventListener('resize', onWindowResize, false);
	document.addEventListener('mousemove', onDocumentMouseMove, false);

	animate();


	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function onDocumentMouseMove(event) {
		event.preventDefault();
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	}

	function animate() {
		requestAnimationFrame(animate);
		controls.update();
		raycaster.setFromCamera(mouse, camera);

		const intersects = raycaster.intersectObjects(scene.children);
		if (intersects.length > 0) {
			if (selectedSegment !== intersects[0].object) {
				if (selectedSegment) {
					selectedSegment.material.emissive.setHex(selectedSegment.currentHex);
				}
				selectedSegment = intersects[0].object;
				selectedSegment.currentHex = selectedSegment.material.emissive.getHex();
				selectedSegment.material.emissive.setHex(0xff0000);
			}
		} else {
			if (selectedSegment) {
				selectedSegment.material.emissive.setHex(selectedSegment.currentHex);
			}
			selectedSegment = null;
		}

		renderer.render(scene, camera);
	}
</script>

</body>
</html>