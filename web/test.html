<!DOCTYPE html>
<html lang="en">
<head>
	<title>Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			background-color: #000000;
			overflow: hidden;
		}
	</style>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/lines/LineSegments2.js"></script>
<script src="js/lines/LineSegmentGeometry.js"></script>
<script src="js/lines/LineMaterial.js"></script>
<script src="js/lines/Lines2.js"></script>
<script src="js/lines/LineGeometry.js"></script>

<script>
	function colourFor(colour, offset) {
		if (offset === 1) {
			colour.setRGB(0, 1, 0);
		} else if (offset === 2) {
			colour.setRGB(0, 0, 1);
		} else {
			colour.setRGB(1, 0, 0);
		}
	}

	const trajectory = [0, 0, 0, 1, 0, 2, 0, 1, 2];

	const renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

	const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(400, 200, 0);

	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0x000000);
	scene.fog = new THREE.FogExp2(0x000000, 0.001);

	//const geometry = new THREE.BoxBufferGeometry(200, 200, 200);
	const geometry = new THREE.CylinderBufferGeometry(50, 50, 600, 3, trajectory.length, true);
	const material = new THREE.MeshPhongMaterial({
		color: 0xFFFFFF,
		flatShading: true,
		vertexColors: THREE.VertexColors,
		shininess: 0,
		side: THREE.DoubleSide,
		opacity: 0.5,
		transparent: true
	});
	//const wireframeGeometry = new THREE.EdgesGeometry(geometry);
	const wireframeMaterial = new THREE.MeshBasicMaterial({
		color: 0x000000,
		wireframe: true,
		opacity: 0.3,
		transparent: true
	});

	const positions = geometry.attributes.position;
	const count = positions.count;
	geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
	let colour = new THREE.Color();
	let vertices = [];
	let lineColours = [];
	const colours = geometry.attributes.color;
	let previous = -1;
	for (let i = 0; i <= trajectory.length; i++) {
		const index = i * 4;
		const current = trajectory[i];
		if (vertices.length === 0) {
			const offset = index + current;
			vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
			colourFor(colour, current);
			lineColours.push(colour.r, colour.g, colour.b)

		} else {
			const offset = index + previous;
			vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
			colourFor(colour, previous);
			lineColours.push(colour.r, colour.g, colour.b)
		}
		if (previous !== current) {
			const offset = index + current;
			vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
			colourFor(colour, current);
			lineColours.push(colour.r, colour.g, colour.b)
		}

		previous = current;

		console.log(positions.getX(index), positions.getY(index), positions.getZ(index));
		colourFor(colour, 0);
		colours.setXYZ(index, colour.r, colour.g, colour.b);
		colourFor(colour, 1);
		colours.setXYZ(index + 1, colour.r, colour.g, colour.b);
		colourFor(colour, 2);
		colours.setXYZ(index + 2, colour.r, colour.g, colour.b);
		colourFor(colour, 0);
		colours.setXYZ(index + 3, colour.r, colour.g, colour.b);
	}

	const lineGeometry = new THREE.LineGeometry();
	lineGeometry.setPositions(vertices);
	lineGeometry.setColors(lineColours);

	const lineMaterial = new THREE.LineMaterial({
		color: 0xffffff,
		linewidth: 0.003,
		vertexColors: THREE.VertexColors,
		//resolution:  // to be set by renderer, eventually
		dashed: false
	});

	const line = new THREE.Line2(lineGeometry, lineMaterial);
	line.computeLineDistances();

	const mesh = new THREE.Mesh(geometry, material);
	const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
	//mesh.add(wireframe);
	mesh.add(line);
	mesh.rotation.x = -Math.PI / 2;
	mesh.rotation.z = -Math.PI;
	scene.add(mesh);


	//const light1 = new THREE.DirectionalLight(0xffffff);
	//light1.position.set(1, 1, 1);
	//scene.add(light1);
	//const light2 = new THREE.DirectionalLight(0x999999);
	//light2.position.set(-1, -1, -1);
	//scene.add(light2);
	const light3 = new THREE.AmbientLight(0xFFFFFF);
	scene.add(light3);

	const controls = new THREE.OrbitControls(camera, renderer.domElement);
	//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
	controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
	controls.dampingFactor = 1;
	controls.screenSpacePanning = false;
	controls.minDistance = 100;
	controls.maxDistance = 500;
	controls.maxPolarAngle = Math.PI;

	window.addEventListener('resize', onWindowResize, false);

	animate();


	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {
		requestAnimationFrame(animate);
		controls.update();
		renderer.render(scene, camera);
	}
</script>

</body>
</html>