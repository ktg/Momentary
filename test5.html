<!DOCTYPE html>
<html lang="en">
<head>
	<title>Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			background-color: #000000;
			overflow: hidden;
		}
	</style>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/lines/LineSegments2.js"></script>
<script src="js/lines/LineSegmentGeometry.js"></script>
<script src="js/lines/LineMaterial.js"></script>
<script src="js/lines/Lines2.js"></script>
<script src="js/lines/LineGeometry.js"></script>

<script>
	const trajectory = [0, 0, 0, 1, 0, 2, 0, 1, 2];
	const size = 50;
	const AMOUNT = 6;

	const length = 50;
	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let selectedSegment = null;

	let segments = [];

	function colourFor(colour, offset) {
		if (offset === 1) {
			colour.setRGB(0, 1, 0);
		} else if (offset === 2) {
			colour.setRGB(0, 0, 1);
		} else {
			colour.setRGB(1, 0, 0);
		}

	}

	function createScene() {
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x000000);

		scene.fog = new THREE.FogExp2(0x000000, 0.001);
		const light = new THREE.AmbientLight(0xFFFFFF);

		scene.add(light);

		createObjects(scene);
		return scene;

	}

	function createToblerone() {
		const geometry = new THREE.CylinderBufferGeometry(size, size, trajectory.length * length, 3, trajectory.length, true);
		const positions = geometry.attributes.position;
		const count = positions.count;
		geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
		const colour = new THREE.Color();

		const colours = geometry.attributes.color;
		for (let i = 0; i < count; i++) {
			colourFor(colour, i % 4);
			colours.setXYZ(i, colour.r, colour.g, colour.b);

		}
		return geometry;

	}

	function createSegments() {
		const geometry = new THREE.CylinderBufferGeometry(size, size, length, 3, 1, true);
		const tobleroneMaterial = new THREE.MeshPhongMaterial({
			color: 0xFFFFFF,
			flatShading: true,
			shininess: 0,
			side: THREE.DoubleSide,
			opacity: 0.5,
			transparent: true
		});
		for (let i = 0; i < trajectory.length; i++) {
			const segment = new THREE.Mesh(geometry, tobleroneMaterial);

			segment.position.z = (i * length) - ((trajectory.length - 1) * length * 0.5);
			segment.rotation.x = -Math.PI / 2;
			segment.rotation.y = -Math.PI;

			segment.rotation.z = -Math.PI;
			segments.push(segment);
		}

	}

	function createLine(positions) {
		let colour = new THREE.Color();
		let vertices = [];
		let lineColours = [];
		let previous = -1;
		for (let i = 0; i <= trajectory.length; i++) {
			const index = i * 4;
			const current = trajectory[i];
			if (vertices.length === 0) {
				const offset = index + current;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, current);

				lineColours.push(colour.r, colour.g, colour.b)
			} else {
				const offset = index + previous;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, previous);
				lineColours.push(colour.r, colour.g, colour.b)
			}
			if (previous !== current) {
				const offset = index + current;
				vertices.push(positions.getX(offset), positions.getY(offset), positions.getZ(offset));
				colourFor(colour, current);
				lineColours.push(colour.r, colour.g, colour.b)

			}
			previous = current;

		}
		const lineGeometry = new THREE.LineGeometry();
		lineGeometry.setPositions(vertices);

		lineGeometry.setColors(lineColours);

		const lineMaterial = new THREE.LineMaterial({
			color: 0xffffff,
			linewidth: 0.003,
			vertexColors: THREE.VertexColors,
			dashed: false
		});
		const line = new THREE.Line2(lineGeometry, lineMaterial);

		line.computeLineDistances();
		return line;

	}

	function createObjects(scene) {
		const tobleroneGeometry = createToblerone();
		const texture = new THREE.TextureLoader().load("textures/texture1.jpg");
		const tobleroneMaterial = new THREE.MeshPhongMaterial({
			color: 0xFFFFFF,
			flatShading: true,
			vertexColors: THREE.VertexColors,
			shininess: 0,
			map: texture,
			side: THREE.DoubleSide,
			opacity: 0.5,
			transparent: true
		});

		const toblerone = new THREE.Mesh(tobleroneGeometry, tobleroneMaterial);

		//toblerone.add(createLine(tobleroneGeometry.attributes.position));

		createSegments();
		toblerone.rotation.x = -Math.PI / 2;
		toblerone.rotation.y = -Math.PI;
		toblerone.rotation.z = -Math.PI;
		scene.add(toblerone);

	}

	const renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);

	document.body.appendChild(renderer.domElement);
	const SIZE = 1 / AMOUNT;
	const ASPECT_RATIO = window.innerWidth / window.innerHeight;
	let cameras = [];
	for (let y = 0; y < AMOUNT; y++) {
		for (let x = 0; x < AMOUNT; x++) {
			const subcamera = new THREE.PerspectiveCamera(40, ASPECT_RATIO, 0.1, 1000);
			subcamera.bounds = new THREE.Vector4(x / AMOUNT, y / AMOUNT, SIZE, SIZE);
			subcamera.position.set(0, 0, 400);
			subcamera.lookAt(new THREE.Vector3());
			subcamera.updateMatrixWorld();
			cameras.push(subcamera);
		}
	}
	const camera = new THREE.ArrayCamera(cameras);
	camera.position.z = 3;

	const scene = createScene();

	window.addEventListener('resize', onWindowResize, false);
	document.addEventListener('mousemove', onDocumentMouseMove, false);

	animate();

	function animate() {
		requestAnimationFrame(animate);
		//controls.update();

		// raycaster.setFromCamera(mouse, camera);
		//
		// const intersects = raycaster.intersectObjects(segments);
		// if (intersects.length > 0) {
		// 	if (selectedSegment !== intersects[0].object) {
		// 		if (selectedSegment) {
		// 			scene.remove(selectedSegment);
		// 		}
		// 		selectedSegment = intersects[0].object;
		// 		scene.add(selectedSegment);
		// 	}
		// } else {
		// 	if (selectedSegment) {
		// 		scene.remove(selectedSegment);
		// 	}
		// 	selectedSegment = null;
		// }
		//
		renderer.render(scene, camera);
	}

	function onDocumentMouseMove(event) {
		event.preventDefault();
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}
</script>
<div id=""></div>
</body>
</html>